<<<<<<< HEAD
<<<<<<< HEAD
name: Deploy Web App

on:
  workflow_run:
    workflows: ["Deploy Infrastructure"]
    types:
      - completed
<<<<<<< HEAD
<<<<<<< HEAD
  workflow_dispatch:
<<<<<<< HEAD
=======
  # workflow_dispatch:
>>>>>>> 648ec81 (Fix(Helper_scripts): few tweaks to correct the destroy flow (#36) (#37))
=======
  workflow_dispatch:
>>>>>>> 7aaa899 (update(cicd): Use matrix strategy and exclude parameter to control the environment deployments (#42))

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
<<<<<<< HEAD
<<<<<<< HEAD
      fail-fast: true
      max-parallel: 1
      matrix:
        environment: ['dev', 'prod']
        exclude:
          - environment: ${{ github.ref != 'refs/heads/develop' && 'prod' }}

    environment:
      name: ${{ matrix.environment }}

    env:
      IMAGE_VERSION_APP: latest
      KUBECONFIG: /home/runner/.kube/config
      KUBE_CONFIG_PATH: /home/runner/.kube/config
=======
name: Terraform & Web App CI/CD Workflow
=======
name: Deploy Web App
>>>>>>> 63b6df2 (Feat: Separate pipelines for infrastructure and app deployments (#33))

on:
  workflow_run:
    workflows: ["Deploy Infrastructure"]
    types:
      - completed
=======
>>>>>>> f27cb71 (Fix(Helper_scripts): few tweaks to correct the destroy flow (#36))

jobs:
<<<<<<< HEAD
  terraform:
    runs-on: ubuntu-latest

    environment:
      name: "${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}"

    env:
>>>>>>> 2c252cb (Refactor: refactoring the project as per the planned design (#28))
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
<<<<<<< HEAD
      TF_VAR_environment:  ${{ matrix.environment }}
      TF_VAR_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  
    steps:

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifact
        id: download-artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          name: infra-outputs-${{ matrix.environment }} 
          check_artifacts: true
          search_artifacts: false
          workflow: deploy-infra-cicd.yml
          path: ./artifacts

      - name: Read JSON and Set Variables
        run: |
          INFRA_OUTPUTS=$(cat ./artifacts/infrastructure-outputs.json)
          export AKS_CLUSTER_NAME=$(echo "$INFRA_OUTPUTS" | jq -r '.AKS_CLUSTER_NAME')
          export AKS_RESOURCE_GROUP=$(echo "$INFRA_OUTPUTS" | jq -r '.AKS_RESOURCE_GROUP')
          export ACR_REGISTRY_NAME=$(echo "$INFRA_OUTPUTS" | jq -r '.ACR_REGISTRY_NAME')

          echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_ENV
          echo "AKS_RESOURCE_GROUP=$AKS_RESOURCE_GROUP" >> $GITHUB_ENV
          echo "ACR_REGISTRY_NAME=$ACR_REGISTRY_NAME" >> $GITHUB_ENV

      - name: Set Up Kubernetes and Azure
        uses: ./.github/actions/k8s-setup-action
        with:
          aks_cluster_name: $AKS_CLUSTER_NAME
          aks_resource_group: $AKS_RESOURCE_GROUP
          acr_registry_name: $ACR_REGISTRY_NAME
          azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
          arm_client_id: $ARM_CLIENT_ID
          arm_subscription_id: $ARM_SUBSCRIPTION_ID
          environment: ${{ matrix.environment }}

      - name: Invoke Docker Build & Push Action
        uses: ./.github/actions/docker-action
        with:
          image_name: ${{ vars.DOCKER_IMAGE_NAME_APP }}
          registry_name: $ACR_REGISTRY_NAME
          version: $IMAGE_VERSION_APP
          working-directory: data-upload-app/src

      - name: Invoke Terraform Composite Action for Helm
        uses: ./.github/actions/terraform-action
        with:
          environment:  ${{ matrix.environment }} 
          working-directory: ./data-upload-app/deployment
          backend-state-name: application
=======

      TF_VAR_environment: "${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create tfvars file from secrets & Print encrypted content
        run: |
          cat <<EOF > deployment/$TF_VAR_environment.tfvars
          ${{ secrets.TFVARS }}
          EOF
          cat deployment/$TF_VAR_environment.tfvars

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      # Terraform Init before First Plan
      - name: Terraform Init (infrastructure)
        run: terraform init
        working-directory: deployment/shared

      # First Plan: Plan infrastructure changes (excluding Helm release)
      - name: Terraform Plan (infrastructure only)
        run: terraform plan -var-file="../$TF_VAR_environment.tfvars" -target=module.acr -target=module.aks -target=module.networking -target=module.storage -out=infra.tfplan
        working-directory: deployment/shared

      # First Apply: Apply the infrastructure changes from the saved plan
      - name: Terraform Apply (infrastructure only)
        run: terraform apply -auto-approve infra.tfplan
        working-directory: deployment/shared

      - name: Get Terraform Outputs
        run: |
          AKS_CLUSTER_NAME=$(terraform output -raw aks_cluster_name)
          AKS_RESOURCE_GROUP=$(terraform output -raw aks_rg_name)
          ACR_REGISTRY_NAME=$(terraform output -raw acr_registry_name)
          echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_ENV
          echo "AKS_RESOURCE_GROUP=$AKS_RESOURCE_GROUP" >> $GITHUB_ENV
          echo "ACR_REGISTRY_NAME=$ACR_REGISTRY_NAME" >> $GITHUB_ENV
        working-directory: deployment/shared

=======
>>>>>>> 63b6df2 (Feat: Separate pipelines for infrastructure and app deployments (#33))
  build-push-deploy:
    runs-on: ubuntu-latest
=======
      matrix:
        environment: [dev]  # Matrix for multiple environments
>>>>>>> 7aaa899 (update(cicd): Use matrix strategy and exclude parameter to control the environment deployments (#42))
=======
      fail-fast: true
      max-parallel: 1
      matrix:
        environment: ['dev', 'prod']
        exclude:
          - environment: ${{ github.ref != 'refs/heads/main' && 'prod' }}
>>>>>>> 2e4e7e2 (Feat(cicd_new_design): Implement Full CI/CD Pipeline with Dynamic Environment Support and Reusable Actions (#44))

    environment:
      name: ${{ matrix.environment }}

    env:
      IMAGE_VERSION_APP: latest
      KUBECONFIG: /home/runner/.kube/config
      KUBE_CONFIG_PATH: /home/runner/.kube/config
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      TF_VAR_environment:  ${{ matrix.environment }}
      TF_VAR_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  
    steps:

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifact
        id: download-artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          name: infra-outputs-${{ matrix.environment }} 
          check_artifacts: true
          search_artifacts: false
          workflow: deploy-infra-cicd.yml
          path: ./artifacts

      - name: Read JSON and Set Variables
        run: |
          INFRA_OUTPUTS=$(cat ./artifacts/infrastructure-outputs.json)
          export AKS_CLUSTER_NAME=$(echo "$INFRA_OUTPUTS" | jq -r '.AKS_CLUSTER_NAME')
          export AKS_RESOURCE_GROUP=$(echo "$INFRA_OUTPUTS" | jq -r '.AKS_RESOURCE_GROUP')
          export ACR_REGISTRY_NAME=$(echo "$INFRA_OUTPUTS" | jq -r '.ACR_REGISTRY_NAME')

          echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_ENV
          echo "AKS_RESOURCE_GROUP=$AKS_RESOURCE_GROUP" >> $GITHUB_ENV
          echo "ACR_REGISTRY_NAME=$ACR_REGISTRY_NAME" >> $GITHUB_ENV

      - name: Set Up Kubernetes and Azure
        uses: ./.github/actions/k8s-setup-action
        with:
          aks_cluster_name: $AKS_CLUSTER_NAME
          aks_resource_group: $AKS_RESOURCE_GROUP
          acr_registry_name: $ACR_REGISTRY_NAME
          azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
          arm_client_id: $ARM_CLIENT_ID
          arm_subscription_id: $ARM_SUBSCRIPTION_ID
          environment: ${{ matrix.environment }}

      - name: Invoke Docker Build & Push Action
        uses: ./.github/actions/docker-action
        with:
          image_name: ${{ vars.DOCKER_IMAGE_NAME_APP }}
          registry_name: $ACR_REGISTRY_NAME
          version: $IMAGE_VERSION_APP
          working-directory: data-upload-app/src

<<<<<<< HEAD
      # Fetch AKS Credentials
      - name: Get AKS Credentials
        run: |
          az aks get-credentials --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --admin --overwrite-existing

      - name: Print Kubernetes context and check nodes
        run: |
          kubectl config current-context
          kubectl get nodes

      # Build and Push Docker image to ACR
      - name: Build & Push Docker Image
        run: |
          docker build -t $ACR_REGISTRY_NAME.azurecr.io/$DOCKER_IMAGE_NAME_WEBAPP:$IMAGE_VERSION_WEBAPP .
          docker push $ACR_REGISTRY_NAME.azurecr.io/$DOCKER_IMAGE_NAME_WEBAPP:$IMAGE_VERSION_WEBAPP
          echo "Verifying repository images in ACR..."
          az acr repository list --name $ACR_REGISTRY_NAME --output table
          echo $TF_VAR_environment
          echo $TF_VAR_subscription_id
        working-directory: data-upload-app/src

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      # Terraform Init before Helm Release
      - name: Terraform Init (Helm)
        run: terraform init
        working-directory: data-upload-app/deployment

      # Terraform Plan for Helm Release
      - name: Terraform Plan (Helm release)
        run: terraform plan -var-file="$TF_VAR_environment.tfvars" -out=app.tfplan
        working-directory: data-upload-app/deployment

      # Apply Helm Release using Terraform
      - name: Terraform Apply (Helm release)
<<<<<<< HEAD
        run: terraform apply -auto-approve webapp.tfplan
        working-directory: deployment/shared
>>>>>>> 2c252cb (Refactor: refactoring the project as per the planned design (#28))
=======
        run: terraform apply -auto-approve app.tfplan
        working-directory: data-upload-app/deployment
>>>>>>> 63b6df2 (Feat: Separate pipelines for infrastructure and app deployments (#33))
=======
      - name: Invoke Terraform Composite Action for Helm
        uses: ./.github/actions/terraform-action
        with:
<<<<<<< HEAD
          environment: ${{ matrix.environment }}
          working-directory: ./data-upload-app/deployment
>>>>>>> 7aaa899 (update(cicd): Use matrix strategy and exclude parameter to control the environment deployments (#42))
=======
          environment:  ${{ matrix.environment }} 
          working-directory: ./data-upload-app/deployment
          backend-state-name: application
>>>>>>> 2e4e7e2 (Feat(cicd_new_design): Implement Full CI/CD Pipeline with Dynamic Environment Support and Reusable Actions (#44))
